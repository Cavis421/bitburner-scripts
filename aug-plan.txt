/** @param {NS} ns */
export async function main(ns) {
    ns.disableLog("ALL");

    // Mode: "hack" (default) or "crime"
    const mode = (ns.args[0] || "hack").toString().toLowerCase();
    if (mode !== "hack" && mode !== "crime") {
        ns.tprint("âŒ Usage: run aug-plan.js [hack|crime]");
        return;
    }

    // How aggressively to plan spending:
    // 0.8 = plan assuming you will spend up to 80% of current money
    const spendFraction = 0.8;

    const player   = ns.getPlayer();
    const factions = player.factions;
    const owned    = new Set(ns.getOwnedAugmentations(true)); // include queued
    const money    = ns.getServerMoneyAvailable("home");
    const budget   = money * spendFraction;

    if (factions.length === 0) {
        ns.tprint("âŒ You haven't joined any factions yet.");
        return;
    }

    ns.tprint("ðŸ§¬ AUGMENT SHOPPING PLANNER");
    ns.tprint(`Mode: ${mode === "hack" ? "Hacking-focused" : "Combat/Crime-focused"}`);
    ns.tprint(`Current money: $${ns.nFormat(money, "0.00a")} (planning with budget: $${ns.nFormat(budget, "0.00a")})`);
    ns.tprint("Scanning factions for available augments...\n");

    /** Collect all non-owned augments from joined factions */
    const entries = [];
    for (const fac of factions) {
        const augs = ns.getAugmentationsFromFaction(fac);
        for (const aug of augs) {
            if (owned.has(aug)) continue; // skip already owned / queued

            const price  = ns.getAugmentationPrice(aug);
            const repReq = ns.getAugmentationRepReq(aug);
            const stats  = ns.getAugmentationStats(aug);

            const score = computeScore(stats, aug, mode);

            entries.push({
                aug,
                faction: fac,
                price,
                repReq,
                score,
                isNeuroFlux: aug.toLowerCase().includes("neuroflux")
            });
        }
    }

    if (entries.length === 0) {
        ns.tprint("âœ… No new augments available (everything is owned or locked).");
        return;
    }

    // Sort: non-NeuroFlux by score desc, then cheaper first
    // NeuroFlux pushed to the end
    entries.sort((a, b) => {
        if (a.isNeuroFlux && !b.isNeuroFlux) return 1;
        if (!a.isNeuroFlux && b.isNeuroFlux) return -1;
        if (b.score !== a.score) return b.score - a.score; // high score first
        return a.price - b.price; // cheaper first
    });

    ns.tprint("Planned augments:");
    ns.tprint("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    ns.tprint(" #   Augmentation                    Faction            Cost       Rep Req       Score    Cum Cost   In Budget?");
    ns.tprint("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

    let cumCost = 0;
    let index   = 1;

    for (const e of entries) {
        cumCost += e.price;
        const inBudget = cumCost <= budget ? "YES" : "no";

        const idxPad   = String(index).padStart(2, " ");
        const augPad   = e.aug.padEnd(28, " ");
        const facPad   = e.faction.padEnd(16, " ");
        const costStr  = ns.nFormat(e.price, "0.00a").padStart(9, " ");
        const repStr   = ns.nFormat(e.repReq, "0.00a").padStart(11, " ");
        const scoreStr = e.score.toFixed(2).padStart(7, " ");
        const cumStr   = ns.nFormat(cumCost, "0.00a").padStart(9, " ");

        ns.tprint(`${idxPad}  ${augPad}  ${facPad}  $${costStr}  ${repStr}  ${scoreStr}  $${cumStr}   ${inBudget}`);

        index++;
    }

    ns.tprint("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    ns.tprint("Legend:");
    if (mode === "hack") {
        ns.tprint("  â€¢ Score is a heuristic based on hacking multipliers (exp, speed, money, chance, rep).");
    } else {
        ns.tprint("  â€¢ Score is a heuristic based on combat/crime multipliers (combat stats, crime, rep).");
    }
    ns.tprint("  â€¢ 'In Budget?' = YES if buying all augments up to that row stays within 80% of your current money.");
    ns.tprint("  â€¢ NeuroFlux Governor (if available) is listed at the bottom as a sink for leftover funds.");
}

/**
 * Compute a rough "value" score for an augmentation depending on mode.
 * mode = "hack"  â†’ focus on hacking multipliers.
 * mode = "crime" â†’ focus on combat + crime + rep multipliers.
 */
function computeScore(stats, augName, mode) {
    const {
        // Hacking-related
        hacking_mult                 = 1,
        hacking_exp_mult             = 1,
        hacking_speed_mult           = 1,
        hacking_money_mult           = 1,
        hacking_chance_mult          = 1,

        // Combat / physical
        strength_mult                = 1,
        defense_mult                 = 1,
        dexterity_mult               = 1,
        agility_mult                 = 1,
        charisma_mult                = 1,

        // Crime / rep
        crime_money_mult             = 1,
        crime_success_mult           = 1,
        faction_rep_mult             = 1,
        company_rep_mult             = 1,
    } = stats;

    let score = 0;

    if (mode === "hack") {
        // Base weights (hacking-focused)
        const wHack       = 5;
        const wHackExp    = 3;
        const wHackSpeed  = 4;
        const wHackMoney  = 5;
        const wHackChance = 2;
        const wFacRep     = 1.5;
        const wComRep     = 0.5;
        const wCrime      = 0.5; // small nod to crime if it helps early money

        score += (hacking_mult        - 1) * wHack;
        score += (hacking_exp_mult    - 1) * wHackExp;
        score += (hacking_speed_mult  - 1) * wHackSpeed;
        score += (hacking_money_mult  - 1) * wHackMoney;
        score += (hacking_chance_mult - 1) * wHackChance;
        score += (faction_rep_mult    - 1) * wFacRep;
        score += (company_rep_mult    - 1) * wComRep;
        score += ((crime_money_mult - 1) + (crime_success_mult - 1)) * wCrime;

    } else if (mode === "crime") {
        // Base weights (combat/crime-focused)
        const wStr        = 3;
        const wDef        = 3;
        const wDex        = 2;
        const wAgi        = 2;
        const wCha        = 1.5;
        const wCrimeMoney = 4;
        const wCrimeSucc  = 4;
        const wFacRep     = 2;
        const wComRep     = 0.5;
        const wHack       = 1; // tiny nod if it also boosts hacking

        score += (strength_mult   - 1) * wStr;
        score += (defense_mult    - 1) * wDef;
        score += (dexterity_mult  - 1) * wDex;
        score += (agility_mult    - 1) * wAgi;
        score += (charisma_mult   - 1) * wCha;
        score += (crime_money_mult   - 1) * wCrimeMoney;
        score += (crime_success_mult - 1) * wCrimeSucc;
        score += (faction_rep_mult   - 1) * wFacRep;
        score += (company_rep_mult   - 1) * wComRep;

        // If an aug helps hacking too, give it a bit of credit
        score += (hacking_mult - 1) * wHack;
    }

    // Small bonus for NeuroFlux as a generic "always good" augment
    if (augName.toLowerCase().includes("neuroflux")) {
        score += 2;
    }

    return score;
}
